# Max Subset Sum No Adjacent
# Write a function that takes in an array of positive integers and returns the maximum sum of non-adjacent elements in the array.
# If the input array is empty, the function should return e.
# Sample Input
# array [75, 105, 120, 75, 90, 135]
# Sample Output
# 330 // 75 + 120 + 135

# This is a problem that can be solved with dynamic programming where we divide the problem into small calculatioms and use them to come up to the correct result
# In this case, we need to understand a pattern/formula to get the max Sum given an array. 
# In the example array [75, 105, 120, 75, 90, 135], we are going to calculate the max sum of the sub array
# [75], then for [75, 105], then for [75, 105, 120] until the last one [75, 105, 120, 75, 90, 135]. The reason we do this is
# that for each sub array we calculate the max Sum, the next maxSum is based on the maxSum of the previous sub arrays.
# In this case, the pattern would be
#  maxSum[i] = max(maxSum[i-1], maxSum[i-2]+array[i])
# Quick highlights about this formula:
# 1) Each new maxSum naturally is greater than the previous one, because the sub array has a greater length therefore more numbers could contribute to the sum
# 2) maxSum[i-2] don't include the number array[i-1] (adjancent of array[i]), 
# given that maxSum[i-2] is generated by the sub array tht goes from 0 to i-2 index. therefore, we can safelly add array[i] to compose the new maxSum[i]


# Time O(n) | Space O(1)
def maxSubsetSumNoAdjacent(array):
    if len(array) == 0: return 0
    if len(array) <= 2: return max(array)
        
    maxSums = [array[0], max(array[0], array[1])]
    for i in range(2,len(array)):
        newSum = max(maxSums[-1], maxSums[-2]+array[i])
        maxSums[-2], maxSums[-1] = maxSums[-1], newSum
        
    return maxSums[-1]